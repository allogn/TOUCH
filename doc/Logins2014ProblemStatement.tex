\documentclass{sig-alternate}
\setlength{\pdfpagewidth}{8.5in}
\setlength{\pdfpageheight}{11in}

\usepackage{graphicx}
\usepackage{balance}  % for  \balance command ON LAST PAGE  (only there!)
\usepackage{subfigure}
\usepackage{enumerate}
\usepackage{color}
%
\usepackage{wrapfig}
\usepackage{hyphenat}
%\usepackage[labelfont=bf,textfont=bf]{caption}
%\usepackage[utf8]{inputenc}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage[noend]{algpseudocode}

\newcommand{\hide}[1]{}
\newcommand{\fref}[1]{Figure \ref{#1}}
\newcommand{\sref}[1]{Section \ref{#1}}
\newcommand{\aref}[1]{Algorithm \ref{#1}}
\newcommand{\tref}[1]{Table \ref{#1}}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{remark}{Remark}


\newcommand{\SJ}{TOUCH}

\renewcommand{\baselinestretch}{0.97}

\begin{document}

\title{cTOUCH and dTOUCH: A Very Workload Balanced In-Memory Spatial Joins by Iterative Hierarchical Data-Oriented Partitioning}
\clubpenalty=10000
\widowpenalty = 10000


\numberofauthors{3}
\author{
\alignauthor Sadegh Nobari
\alignauthor Panagiotis Karras
\and
\alignauthor Alvis Logins
\and\affaddr{Skoltech institute of science and technology}
}


\maketitle

\begin{abstract}
We are devising three novel algorithms, called reTOUCH, that are inspired by the TOUCH algorithm. Since we are dealing with big data, we need to exploit the ubiquitous parallel processors, e.g. GPU and CPU. These architectures are well designed for independent balanced workloads. Thanks to the TOUCH algorithm, the workloads are independent. However, we need balanced workloads as well. The reTOUCH algorithms are designed with the idea of creating balanced workload by reducing the asymmetry of the TOUCH algorithms as much as possible. These algorithms create indexes that produce even workloads for the actual job. In this paper we empirically examine each design and we find superiority domain of each algorithm.
\end{abstract}


\section{Problem statement}
TOUCH does the spatial join of objects. Given objects of two classes we are looking for all intersections between objects of opposite classes. For example, we have some distribution of dendrites in a space. Every dendrite has its own shape and position. All dendrites are objects of first type. Then, we have objects of second type. In our example they are axons. They also have some spatial distribution. Our goal is to find such dendrites that are close enough to axons. If so, we can conclude that they are connected. Fast joining algorithm allows to reconstruct the whole net of neurones. Problem of finding close enough objects can be transformed to a problem of finding intersections by adding a sphere of radius $\epsilon$ to each object, where $\epsilon$ is the distance we are checking. The main goal of current research is to change original TOUCH algorithm in the way to allow efficient parallelization of tasks. It should be flexible to the various densities of both types. For example, if there are some place in a space where lots of objects of first dataset are located and a very few of second, then the original algorithm would be very sensitive to the order of density of these datasets. This is also connected with impossibility of parallelization of original TOUCH. Firstly, the search tree (R-tree) is build using one of types of objects and objects of other type are assigned to the nodes of this tree on the such level to minimize numbers of intersection checks with objects in the tree below the node they are assigned. Our new algorithm should remove this property and either build two separate R-trees or build one complex R-tree using both types together. This should lead to equal distribution of tasks between nodes in the search tree and possible parallelization of join phase, where we check assigned objects for intersection with underlying objects in the tree. 

\section{Description of datasets}
Data contains spatial objects from two datasets. The main goal of the algorithm is to find intersections between all objects of the first dataset with all objects from the second dataset. Lets call the affiliation of objects to datasets as types of these objects. Each object has its spatial shape, coordinates and MBR (minimum bounding box). We work with 3D data, however it could be generalized to n-dimensions. Objects are not evenly distributed in space and their shape can be any. Data about human brain will be used for experiments, which are generated by BlueGene model. The size of the objects can also differ significantly. Our algorithm must have improvements on the data with high difference between two datasets and high independent distribution of shape and position, in comparison with previous approach, where the distribution must be correlated between two datasets.

\section{Algorithm}
The algorithm takes spatial objects of two types and outputs the list of objects that intersects with at objects of opposite type. Algorithm contains building, assignment and joining step. Firstly, the R-tree for datasets is built, then objects are assigned to the nodes of the tree. During the last step objects assigned to nodes are checked for intersection with their children.

\section{Restrictions}
We will use only 3D and two types of objects. No restriction on spatial parameters of objects.

\section{Quality}
The quality criteria is the performance on the data with various types of distribution of parameters like density, object sizes etc. The faster the algorithm is (comparing with previous approaches) the better.

\section{Optimization}
There are number of parameters, which must be tuned for effective work. These are: maximum height of possible assignment, fanout (number of objects in a node), maximum capacity of a node on assignment step, number of objects per bucket.

\section{Model for exploitation}
The final product will be the command-line program with two datasets for input (list of coordinates and type). Output will be the performance of the algorithm and the list of intersections.

\section{Basic algorithm}

\subsection{Original TOUCH algorithm}
The original TOUCH algorithm consists of building R-Tree step, Assignment step and Joining step.

\begin{algorithm}
\caption{TOUCH algorithm, building R-Tree step}
\label{alg:touchcodepartitions}
\begin{algorithmic}[1]
\Function{createPartitions}{$dataset_A$}
\State{$nextInput \gets [dataset, level=0]$} 
\While{$dataset$ is not empty}
  \State{$[dataset, level] \gets nextInput$}
  \State{Sort($dataset$)}
  \State{split $dataset$ into parts $ds$ with size of $nodeSize$}
  \ForAll{$ds$ in $dataset$}
    \State{$totalMBR$ = new $MBR$}
    \ForAll{$object$ in $ds$}
      \State{$totalMBR \gets objectMBR$}
      \Comment{expand MBR of current node}
      \State{$tree \gets [object, level]$}
      \State{$nextInput \gets$ new $object$($totalMBR$, $level = $ size of $tree$)} 
    \EndFor
  \EndFor
\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{TOUCH algorithm, Assignment step}\label{touchcodeassign}
\begin{algorithmic}[1]
\Function{assignment}{$dataset_B$}
  \ForAll{$b$ in $dataset_B$}
    \State{$currentNode = $top($tree$)}
    \Loop
      \ForAll{$object$ in $currentNode$}      
	\If{$b$ intersects one $object$}
	  \State{$currentNode$ = $object$}
	\EndIf
	\If{$b$ interects more than one $object$}
	  \State{assign $b$ to $currentNode$}
	\EndIf
      \EndFor
    \EndLoop
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{TOUCH algorithm, Join step}\label{touchcodejoin}
\begin{algorithmic}[1]
\Function{probe}{$tree$}
  \ForAll{$node$ in $tree$}
    \If{number of objects from $dataset_B$ in $node >$ 0}
      \ForAll{child leafs of $node$}
	\State{join($leaf$, $node$)}
	\Comment{Plane-sweeping join algorithm}
      \EndFor
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{dTOUCH (double TOUCH)}
This modification is based on building two separate R-trees. First step is building R-tree using objects from dataset A. dTOUCH has the building step the same as original TOUCH algorithm (ref. \ref{alg:touchcodepartitions}). After it, we assign objects of dataset B to this tree. During the assignment phase the level of the node where we decide to assign our object represents the workload for joining step. Lower level corresponds to easier joining because every assigned object must be checked with all leafs - descenders and number of descenders grows exponentially with the level.  Here the key idea for dTOUCH goes: lets restrict assignment to high levels of the tree. Now we do the assignment of objects of dataset B to the tree built from objects of dataset A the same way as in original TOUCH but only to the levels below some parameter MAX\_LEVEL. 

\begin{algorithm}
\caption{dTOUCH algorithm, Assignment restriction part}\label{touchcodeassign}
\begin{algorithmic}[1]
\Function{assignment}{$dataset_B$}
  \ForAll{$b$ in $dataset_B$}
    \State{$currentNode = $top($tree$)}
    \Loop
      \ForAll{$object$ in $currentNode$}      
	\If{$b$ intersects one $object$}
	  \State{$currentNode$ = $object$}
	\EndIf
	\If{$b$ intersects more than one $object$}
	  \If{level of $object <=$  max\_level}
	    \State{assign $b$ to $currentNode$}
	    \State{delete $b$ from $dataset_B$}
	  \EndIf
	\EndIf
      \EndFor
    \EndLoop
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

After we have done assignment step, we have some objects B filtered, some assigned and some ignored due to level restriction. Ignored data can probably intersect with some of objects of opposite type. This ignoring corresponds to the situation when the size of object B in space is much larger than all objects of dataset A or just intersect with considerable amount of them. In this case it is more efficient to change roles of A and B dataset and assign objects of dataset A. Sequentially, lets build one more R-tree using this ignored data from dataset B and assign all objects from dataset A to this new small tree. This time do not use any restrictions on level avoiding any result loss. Finally, do the joining using both trees the same way as in original TOUCH.

\subsection{cTOUCH (complex TOUCH)}
The key idea of rewriting TOUCH code is making the algorithm symmetric to A and B datasets. In this implementation we will try to build one symmetric R-tree, using both datasets as equally as possible. For pretty illustrating the principals of the approach lets introduce some colors and definitions. Let objects ($o$) from dataset A be red objects (\textcolor{red}{$o$}) and from dataset B - blue objects (\textcolor{blue}{$o$}). Each objects has its own MBR ($ \square $) that has corresponding color. Let MBR of the node i on the level l be red ($v^l_i \leftarrow \textcolor{red}{\square}^l_i$) if it was built as intersection of all red MBRs of the children ($\textcolor{red}{\square}^{l}_i = \bigcup\textcolor{red}{\square}^{l}_{i-1}$). Lets MBR of the node be blue if it was built from blue ones. Let MBR be black ($\square^{l}_i$) if it was build as intersection of blue and red MBRs. Let the assigned red objects be dark red ($\textcolor{red}{\blacksquare}^{l}_i$) and assigned blue - dark blue ($\textcolor{blue}{\blacksquare}^{l}_i$).

\subsubsection{Overview}Finished with colors, now the introduction to the algorithm goes. The algorithm consists of the same steps as original TOUCH: building, assignment and joining steps. During the building step we take all objects of both colors, build leaf nodes (create initial groups of objects) and build one mutual R-tree using Hilbert curve for indexing starting from leafs and creating two MBR per each node. Assignment phase is about taking all the objects from the leafs of the tree and assigning them to the tree traversing from the root to the leafs. At the joining step for each node we check the intersection of assigned object with all assigned objects which were assigned to the descenders of the node.

\paragraph{Reminder} $\square^{l}_i$ is MBR where l - level in the tree, i - index of the node where it must be located.

\subsubsection{Building phase}
See the algorithm \ref{alg:cTOUCHb}.

\begin{algorithm}
\caption{cTOUCH algorithm, Building phase}
\label{alg:cTOUCHb}
\begin{algorithmic}[1]
\State{$\textcolor{red}{\square}^{0}_i \leftarrow \textcolor{red}{o}_i$}
\State{$\textcolor{blue}{\square}^{0}_i \leftarrow \textcolor{blue}{o}_i$}
\State{$\forall j \quad v^0_j \leftarrow \textcolor{red}{\square}^{0}_i, \textcolor{blue}{\square}^{0}_i \quad i \in \{jC,jC+1,...,(j+1)C\}$}
\Comment{$C$ - leaf capacity}
\State{$\forall v^0_j \quad \square^{0}_j \leftarrow \textcolor{red}{\square}^{0}_j \cup \textcolor{blue}{\square}^{0}_j$}
\State{$\Omega \leftarrow v^0_j\quad \forall j$}

\While{size($\Omega$) $\neq 1$}
  \State{$v^{l}_i \leftarrow \Omega$}
  \State{Sort $v^l_i$ by $\square^{l}_i$ using Hilbert curve}
  \State{$\forall n \quad \omega_n \leftarrow v_i \quad i\in \{ jF, j(F+1), ..., (j+1)F\} $}
  \Comment{$F$ - fanout}
  \ForAll{$j$}
    \ForAll{$\textcolor{blue}{\square}^{l}_i, \textcolor{red}{\square}^{l}_i \leftarrow \omega_n$}
      \State{$\textcolor{blue}{\square}^{(l+1)}_j \leftarrow \bigcup_i \textcolor{blue}{\square}^{l}_i$}
      \State{$\textcolor{red}{\square}^{(l+1)}_j \leftarrow \bigcup_i \textcolor{red}{\square}^{l}_i$}
      \State{$v^{(l+1)}_j \leftarrow \textcolor{red}{\square}^{(l+1)}_j, \textcolor{blue}{\square}^{(l+1)}_j$}
      \State{$E \leftarrow (i,j)$}
      \Comment{$E$ - set of edges of the tree}
      \State{$\Omega \leftarrow v^{(l+1)}_j$}
    \EndFor
  \EndFor
\EndWhile
\State{Root $\leftarrow \Omega$}
\end{algorithmic}
\end{algorithm}


\subsubsection{Assignment phase}
See the algorithm \ref{alg:cTOUCHa}.

\begin{algorithm}
\caption{cTOUCH algorithm, Assignment phase}
\label{alg:cTOUCHa}
\begin{algorithmic}[1]
\ForAll{$v^0_i$}
  \ForAll{$\textcolor{red}{o} \leftarrow v^0_i$}
    \State{$v^l_j = $ Root}
    \Loop
      \State{$\omega = \{v^{l-1}_k : o^r \cap (\textcolor{blue}{\square}^{(l-1)}_k \cup \textcolor{blue}{\blacksquare}^{(l-1)}_k) \neq \varnothing , (k,j) \in E$ \} }
      \If{$\omega = \varnothing$}
	\State{Filter $\textcolor{red}{o}$}
	\State{Break}
      \EndIf
      \If{size($\omega$) $= 1$}
	\State{$v^l_j \leftarrow \omega$}
      \EndIf
      \If{size($\omega$) $> 1$ or $v^l_j$ - leafnode}
	\State{$v^l_j \leftarrow \textcolor{red}{o}$}
	\For{$l' \geq l$}
	  \State{$\textcolor{red}{\blacksquare}^{l'}_k \leftarrow \textcolor{red}{\square}^{l}_j \quad \forall (k,j) \in E$}
	\EndFor
	\State{Break}
      \EndIf
    \EndLoop
  \EndFor
  \State{Delete $\textcolor{red}{\square}^{0}_i$}
  \ForAll{$l > 0$ and $k : (k,i) \in E$}
    \State{$\textcolor{red}{\square}^{l}_k \leftarrow \bigcup_j\textcolor{red}{\square}^{(l-1)}_j \quad \forall j : (j,k) \in E$}
  \EndFor
  
  \ForAll{$\textcolor{blue}{o} \leftarrow v^0_i$}
    \State{$v^l_j = $ Root}
    \Loop
      \State{$\omega = \{v^{l-1}_k : \textcolor{red}{o} \cap (\textcolor{red}{\square}^{(l-1)}_k \cup \textcolor{red}{\blacksquare}^{(l-1)}_k) \neq \varnothing , (k,j) \in E$ \} }
      \If{$\omega = \varnothing$}
	\State{Filter $\textcolor{blue}{o}$}
	\State{Break}
      \EndIf
      \If{size($\omega$) $= 1$}
	\State{$v^l_j \leftarrow \omega$}
      \EndIf
      \If{size($\omega$) $> 1$ or $v^l_j$ - leafnode}
	\State{$v^l_j \leftarrow \textcolor{blue}{o}$}
	\For{$l' \geq l$}
	  \State{$\textcolor{blue}{\blacksquare}^{l'}_k \leftarrow \textcolor{blue}{\square}^{l}_j \quad \forall (k,j) \in E$}
	\EndFor
	\State{Break}
      \EndIf
    \EndLoop
  \EndFor
  
  \ForAll{$l > 0$ and $k : (k,i) \in E$}
    \State{$\textcolor{blue}{\square}^{l}_k \leftarrow \bigcup_j\textcolor{blue}{\square}^{(l-1)}_j \quad \forall j : (j,k) \in E$}
  \EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

\subsubsection{Joining phase}

See the algorithm \ref{alg:cTOUCHj}.

\begin{algorithm}
\caption{cTOUCH algorithm, Joining phase}
\label{alg:cTOUCHj}
\begin{algorithmic}[1]
\ForAll{$v^l_i$}
  \ForAll{$\textcolor{red}{o} \leftarrow v^l_i$}
    \ForAll{$v^{l'}_j : l' \leq l, j \in E$}
      \ForAll{$\textcolor{blue}{o} \leftarrow v^{l'}_j$}
	\If{$\textcolor{blue}{o} \cap \textcolor{red}{o} \neq \varnothing$}
	  \State{Result $\leftarrow (\textcolor{red}{o}, \textcolor{blue}{o})$}
	\EndIf
      \EndFor
    \EndFor
  \EndFor
  
  \ForAll{$\textcolor{blue}{o} \leftarrow v^l_i$}
    \ForAll{$v^{l'}_j : l' \leq l, j \in E$}
      \ForAll{$\textcolor{red}{o} \leftarrow v^{l'}_j$}
	\If{$\textcolor{red}{o} \cap \textcolor{blue}{o} \neq \varnothing$}
	  \State{Result $\leftarrow (\textcolor{red}{o}, \textcolor{blue}{o})$}
	\EndIf
      \EndFor
    \EndFor
  \EndFor
  
  \ForAll{$\textcolor{blue}{o}, \textcolor{red}{o} \leftarrow v^l_i$}
      \If{$\textcolor{blue}{o} \cap \textcolor{red}{o} \neq \varnothing$}
	\State{Result $\leftarrow (\textcolor{red}{o}, \textcolor{blue}{o})$}
      \EndIf
  \EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

\subsection{Cost of object}
In both cTOUCH and dTOUCH implementation each object has a cost $Z$. This number shows approximate upper bound for number of comparisons of this object with every object of opposite type in the descender nodes during the Join phase. Due to independence of the processing of each object during the joining phase, they can be distributed among processors and must be distributed equally in the meaning of workload. Having such cost number we can implement greedy algorithm to distribute tasks between processors. Cost is calculated using the information about the number of MBRs which intersects with the object. This number is calculated during the assignment phase (for all implementations of TOUCH) and it must be calculated anyway either we use cost estimation or not. So, we do not increase time for assignment step. Given the number of intersections with MBRs of children, $c$, lets estimate cost for cTOUCH and dTOUCH.
\paragraph{dTOUCH} Here objects are assigned in nodes but can be joined only with objects in leafs. So, given the level of our assigned object $l$, we have $cF^l$ leafs each containing $C$ objects. Here, we assume that on each level below our object intersect with every MBR of opposite type and there are $F$ (fanout) MBRs on each level. 
$$ Z = cCF^l$$
\paragraph{cTOUCH}
Here objects can be joined at every node and every level of the tree. So, we will calculate the number of possible comparisons during the assignment step. Each time we assign an object to the node, we add 1 to every assigned object of the opposite type in every ancestor of the node.
$$Z(\textcolor{red}{o}_i \leftarrow v^l_i) = N\{o^b_j \leftarrow v^{l'}_j : (i,j) \in E \quad \& \quad l' > l\}$$ 

\bibliographystyle{abbrv}
%\bibliography{sigfp132-nobari}
%\bibliographystyle{abbrvnat}

\begin{thebibliography}{10}
\vspace{2mm}

\bibitem{joinSelectivity}
W.~G. Aref and H.~Samet.
\newblock {A Cost Model for Query Optimization Using R-Trees}.
\newblock In {\em GIS '94}.

\bibitem{cascadedquadtree}
W.~G. Aref and H.~Samet.
\newblock {Cascaded Spatial Join Algorithms with Spatially Sorted Output}.
\newblock In {\em GIS '96}.

\bibitem{hashing}
W.~G. Aref and H.~Samet.
\newblock {Hashing by Proximity to Process Duplicates in Spatial Databases}.
\newblock In {\em CIKM '94}.

\bibitem{prtree}
L.~Arge, M.~de~Berg, H.~J. Haverkort, and K.~Yi.
\newblock {The Priority R-tree: a practically efficient and worst-case optimal
  R-tree}.
\newblock In {\em {SIGMOD '04}}.

\bibitem{sssj}
L.~Arge, O.~Procopiuc, S.~Ramaswamy, T.~Suel, and J.~S. Vitter.
\newblock {Scalable Sweeping-Based Spatial Join}.
\newblock In {\em VLDB '98}.

\bibitem{rstartree}
N.~Beckmann, H.-P. Kriegel, R.~Schneider, and B.~Seeger.
\newblock {The R*-Tree: an efficient and robust access method for points and
  rectangles}.
\newblock {\em SIGMOD Record}, 19(2):322--331, 1990.

\bibitem{join:RTree}
T.~Brinkhoff, H.-P. Kriegel, and B.~Seeger.
\newblock {Efficient Processing of Spatial Joins Using R-Trees}.
\newblock In {\em SIGMOD '93}.

\bibitem{deduplication}
J.-P. Dittrich and B.~Seeger.
\newblock {Data Redundancy and Duplicate Detection in Spatial Join Processing}.
\newblock In {\em ICDE 2000}.

\bibitem{databasefundamentals}
R.~Elmasri and S.~B. Navathe.
\newblock {\em Fundamentals of Database Systems}.
\newblock Addison Wesley, 3rd edition, 2000.

\bibitem{pais}
A.~Farris, A.~Sharma, C.~Niedermayr, D.~Brat, D.~Foran, F.~Wang, J.~Saltz,
  J.~Kong, L.~Cooper, T.~Oh, T.~Kurc, T.~Pan, and W.~Chen.
\newblock {A Data Model and Database for High-resolution Pathology Analytical
  Image Informatics}.
\newblock {\em Journal of Pathology Informatics}, 2(1):32, 2011.

\bibitem{tgstree}
Y.~J. Garc\'ia, M.~A. L\'opez, and S.~T. Leutenegger.
\newblock {A Greedy Algorithm for Bulk Loading R-trees}.
\newblock In {\em GIS '96}.

\bibitem{peptidefolding}
S.~Gnanakaran, H.~Nymeyer, J.~Portman, K.~Y. Sanbonmatsu, and A.~E. Garcia.
\newblock Peptide folding simulations.
\newblock {\em Current Opinion in Structural Biology}, 13(2):168--174, 2003.

\bibitem{rtree}
A.~Guttman.
\newblock {R-trees: a Dynamic Index Structure for Spatial Searching}.
\newblock In {\em SIGMOD '84}.

\bibitem{patchclamp}
O.~P. Hamill, A.~Marty, E.~Neher, B.~Sakmann, and F.~J. Sigworth.
\newblock {Improved Patch-clamp Techniques for High-resolution Current
  Recording from Cells and Cell-free Membrane Patches}.
\newblock {\em Pfl\"ugers Archiv European Journal of Physiology}, 391:85--100,
  1981.

\bibitem{spatialjointechniques}
E.~H. Jacox and H.~Samet.
\newblock {Spatial Join Techniques}.
\newblock {\em ACM TODS '07}.

\bibitem{index:HilbertRTree}
I.~Kamel and C.~Faloutsos.
\newblock {Hilbert R-tree: An Improved R-tree using Fractals}.
\newblock In {\em VLDB '94}.

\bibitem{join:SizeSeparation}
N.~Koudas and K.~C. Sevcik.
\newblock {Size Separation Spatial Join}.
\newblock In {\em SIGMOD '97}.

\bibitem{tabulating}
J.~Kozloski, K.~Sfyrakis, S.~Hill, F.~Sch\"urmann, C.~Peck, and H.~Markram.
\newblock {Identifying, Tabulating, and Analyzing Contacts Between Branched
  Neuron Morphologies}.
\newblock {\em {IBM} {J}ournal of {R}esearch and {D}evelopment},
  52(1/2):43--55, 2008.

\bibitem{str}
S.~Leutenegger, M.~Lopez, and J.~Edgington.
\newblock {STR: a Simple and Efficient Algorithm for R-Tree Packing}.
\newblock In {\em ICDE '97}.

\bibitem{join:Hash}
M.-L. Lo and C.~V. Ravishankar.
\newblock {Spatial Hash-Joins}.
\newblock In {\em SIGMOD '96}.

\bibitem{join:SeededTree}
M.-L. Lo and C.~V. Ravishankar.
\newblock {Spatial Joins Using Seeded Trees}.
\newblock In {\em SIGMOD '94}.

\bibitem{join:nonblocking}
G.~Luo, J.~F. Naughton, and C.~J. Ellmann.
\newblock A non-blocking parallel spatial join algorithm.
\newblock In {\em ICDE}, pages 697--705, 2002.

\bibitem{join:SlotIndex}
N.~Mamoulis and D.~Papadias.
\newblock {Slot Index Spatial Join}.
\newblock {\em IEEE TKDE}, 15(1):211--231, 2003.

\bibitem{joinprocessing}
P.~Mishra and M.~H. Eich.
\newblock {Join Processing in Relational Databases}.
\newblock {\em ACM Computing Surveys}, 24(1):63--113, 1992.

\bibitem{nobariGPU}
S.~Nobari, T.-T. Cao, P.~Karras, and S.~Bressan.
\newblock Scalable parallel minimum spanning forest computation.
\newblock In {\em Proceedings of the 17th ACM SIGPLAN symposium on Principles
  and Practice of Parallel Programming}, PPoPP '12, pages 205--214, New York,
  NY, USA, 2012. ACM.

\bibitem{twophasejoin}
J.~Orenstein.
\newblock {A Comparison of Spatial Query Processing Techniques for Native and
  Parameter Spaces}.
\newblock In {\em SIGMOD '90}.

\bibitem{join:PBSM}
J.~M. Patel and D.~J. DeWitt.
\newblock {Partition Based Spatial-Merge Join}.
\newblock In {\em SIGMOD '96}.

\bibitem{computationalgeometry}
F.~Preparata and M.~Shamos.
\newblock {\em Computational Geometry: An Introduction}.
\newblock Springer, 1993.

\bibitem{rplustree}
T.~K. Sellis, N.~Roussopoulos, and C.~Faloutsos.
\newblock {The R+-Tree: A Dynamic Index for Multi-Dimensional Objects}.
\newblock In {\em VLDB '87}.

\bibitem{gis}
M.~Ubell.
\newblock {The Montage Extensible DataBlade Architecture}.
\newblock In {\em SIGMOD '94}.

\end{thebibliography}
\end{document}

